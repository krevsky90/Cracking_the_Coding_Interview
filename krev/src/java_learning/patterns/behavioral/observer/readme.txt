info:
https://refactoring.guru/ru/design-patterns/observer

idea:
хранить внутри объекта издателя (Publisher) список ссылок на объекты подписчиков,
причём издатель не должен вести список подписки самостоятельно.
Он предоставит методы subscribe/unsubscribe подписчикам

когда издатель вызывает метод типа doSmth(), он проходит по списку своих подписчиков и дергает их метод типа update()

Пример:
издание, подписчики

NOTE:
0) список подписчиков можно трекать внутри издателя
ИЛИ внутри отдельного subscriberManager-a, ссылку на к-ого хранит издатель
1) subscriber может подписаться на несколько разных publisher-ов
2) если publisher-ов несколько, то им логично иметь одинаковый интерфейс с методами subscribe/unsubscribe
3) все подписчики имеют один интерфейс с методом update().
    это позволяет хранить разных подписчиков в одном листе издателя



Применимость:
1)  Когда после изменения состояния одного объекта требуется что-то сделать в других, но вы не знаете наперёд, какие именно объекты должны отреагировать.
    например, подписаться на событие UI кнопки

2) Когда одни объекты должны наблюдать за другими, но только в определённых случаях.

 Шаги реализации:
1 Разбейте вашу функциональность на две части: независимое ядро и опциональные зависимые части.
    Независимое ядро станет издателем. Зависимые части станут подписчиками.

2 Создайте интерфейс подписчиков. Обычно в нём достаточно определить единственный метод оповещения.

3 Создайте интерфейс издателей и опишите в нём операции управления подпиской.
    Помните, что издатель должен работать только с общим интерфейсом подписчиков.

4 Вам нужно решить, куда поместить код ведения подписки, ведь он обычно бывает одинаков для всех типов издателей.
    Самый очевидный способ — вынести этот код в промежуточный абстрактный класс, от которого будут наследоваться все издатели.
    НО если вы интегрируете паттерн в существующие классы, то создать новый базовый класс может быть затруднительно.
    В этом случае вы можете поместить логику подписки во вспомогательный объект и делегировать ему работу из издателей.

5 Создайте классы конкретных издателей. Реализуйте их так, чтобы после каждого изменения состояния они отправляли оповещения всем своим подписчикам.

6 Реализуйте метод оповещения в конкретных подписчиках.
    Не забудьте предусмотреть параметры, через которые издатель мог бы отправлять какие-то данные, связанные с происшедшим событием.
    Возможен и другой вариант, когда подписчик, получив оповещение, сам возьмёт из объекта издателя нужные данные. Н
        НО в этом случае вы будете вынуждены привязать класс подписчика к конкретному классу издателя.