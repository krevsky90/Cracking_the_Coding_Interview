info:
https://refactoring.guru/ru/design-patterns/state

idea:
который позволяет объектам менять поведение в зависимости от своего состояния.

Пример:
любая state-машина с переходами состояний:
кофемашина, плеер


Применимость:
1)   Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния,
    причём типов состояний много, и их код часто меняется.

2) Когда код класса содержит множество больших, похожих друг на друга, условных операторов,
    которые выбирают поведения в зависимости от текущих значений полей класса.

3) Когда вы сознательно используете табличную машину состояний, построенную на условных операторах,
    но вынуждены мириться с дублированием кода для похожих состояний и переходов.

 Шаги реализации:
1 Определитесь с классом, который будет играть роль контекста.
    Это может быть как существующий класс, в котором уже есть зависимость от состояния,
    так и новый класс, если код состояний размазан по нескольким классам.

2 Создайте общий интерфейс состояний. Он должен описывать методы, общие для всех состояний, обнаруженных в контексте.
    Заметьте, что не всё поведение контекста нужно переносить в состояние, а только то, которое зависит от состояний.

3 Для каждого фактического состояния создайте класс, реализующий интерфейс состояния.
    Переместите код, связанный с конкретными состояниями в нужные классы.
    В конце концов, все методы интерфейса состояния должны быть реализованы во всех классах состояний.

    NOTE: При переносе поведения из контекста вы можете столкнуться с тем, что это поведение зависит от приватных полей или методов контекста,
        к которым нет доступа из объекта состояния. Существует парочка способов обойти эту проблему.

        a) оставить поведение внутри контекста, вызывая его из объекта состояния.
        b) сделать классы состояний вложенными в класс контекста,
            и тогда они получат доступ ко всем приватным частям контекста.
            Но последний способ доступен только в некоторых языках программирования (например, Java, C#).

4 Создайте в контексте поле для хранения объектов-состояний, а также публичный метод для изменения значения этого поля.

5 Старые методы контекста, в которых находился зависимый от состояния код, замените на вызовы соответствующих методов объекта-состояния.

6 В зависимости от бизнес-логики, разместите код, который переключает состояние контекста
    либо внутри контекста, либо внутри классов конкретных состояний.

5 Создайте классы конкретных издателей. Реализуйте их так, чтобы после каждого изменения состояния они отправляли оповещения всем своим подписчикам.

6 Реализуйте метод оповещения в конкретных подписчиках.
    Не забудьте предусмотреть параметры, через которые издатель мог бы отправлять какие-то данные, связанные с происшедшим событием.
    Возможен и другой вариант, когда подписчик, получив оповещение, сам возьмёт из объекта издателя нужные данные. Н
        НО в этом случае вы будете вынуждены привязать класс подписчика к конкретному классу издателя.